-- Flow-Ledger Expense schema (PostgreSQL 12+)

CREATE SCHEMA IF NOT EXISTS expense;

CREATE OR REPLACE FUNCTION expense.tg_set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN NEW.updated_at := now(); RETURN NEW; END $$;

CREATE TABLE IF NOT EXISTS expense.expense_categories (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id    BIGINT NOT NULL REFERENCES "user".users(id) ON DELETE CASCADE,
  name       TEXT NOT NULL,
  parent_id  BIGINT NULL REFERENCES expense.expense_categories(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_expense_categories__user_name UNIQUE (user_id, name)
);

DROP TRIGGER IF EXISTS trg_expense_categories__upd ON expense.expense_categories;
CREATE TRIGGER trg_expense_categories__upd
BEFORE UPDATE ON expense.expense_categories
FOR EACH ROW EXECUTE FUNCTION expense.tg_set_updated_at();

CREATE TABLE IF NOT EXISTS expense.expenses (
  id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id         BIGINT NOT NULL REFERENCES "user".users(id) ON DELETE RESTRICT,
  amount          NUMERIC(20,6) NOT NULL,
  currency        TEXT   NOT NULL REFERENCES currency.currencies(code) ON DELETE RESTRICT,
  category_id     BIGINT NULL REFERENCES expense.expense_categories(id) ON DELETE SET NULL,
  merchant        TEXT   NULL,
  tags            TEXT[] NULL,
  paid_account_id BIGINT NULL REFERENCES deposit.institutions(id) ON DELETE SET NULL,
  occurred_at     TIMESTAMPTZ NOT NULL,
  source_ref      TEXT   NULL,
  note            TEXT   NULL,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_expenses__amount_positive CHECK (amount >= 0)
);

DROP TRIGGER IF EXISTS trg_expenses__upd ON expense.expenses;
CREATE TRIGGER trg_expenses__upd
BEFORE UPDATE ON expense.expenses
FOR EACH ROW EXECUTE FUNCTION expense.tg_set_updated_at();

-- Idempotency for external imports when source_ref is provided
CREATE UNIQUE INDEX IF NOT EXISTS idx_expenses__user_source_ref
ON expense.expenses (user_id, source_ref)
WHERE source_ref IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_expenses__user_occurred_at_desc
ON expense.expenses (user_id, occurred_at DESC);

