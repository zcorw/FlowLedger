-- Flow-Ledger Deposit schema (PostgreSQL 12+)

CREATE SCHEMA IF NOT EXISTS deposit;

CREATE OR REPLACE FUNCTION deposit.tg_set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN NEW.updated_at := now(); RETURN NEW; END $$;

-- Sync latest balance into financial_products.amount when the newest snapshot is written
CREATE OR REPLACE FUNCTION deposit.tg_sync_product_amount()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  latest_ts TIMESTAMPTZ;
BEGIN
  SELECT max(as_of) INTO latest_ts
  FROM deposit.product_balances
  WHERE product_id = NEW.product_id;

  IF latest_ts IS NOT NULL AND NEW.as_of = latest_ts THEN
    UPDATE deposit.financial_products
    SET amount = NEW.amount, amount_updated_at = NEW.as_of, updated_at = now()
    WHERE id = NEW.product_id;
  END IF;
  RETURN NEW;
END $$;

CREATE TABLE IF NOT EXISTS deposit.institutions (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id    BIGINT NOT NULL REFERENCES "user".users(id) ON DELETE CASCADE,
  name       TEXT NOT NULL,
  type       TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_institutions__type CHECK (type IN ('bank','broker','other')),
  CONSTRAINT uq_institutions__user_name UNIQUE (user_id, name)
);

CREATE INDEX IF NOT EXISTS idx_institutions__user_id ON deposit.institutions(user_id);

DROP TRIGGER IF EXISTS trg_institutions__upd ON deposit.institutions;
CREATE TRIGGER trg_institutions__upd
BEFORE UPDATE ON deposit.institutions
FOR EACH ROW EXECUTE FUNCTION deposit.tg_set_updated_at();

CREATE TABLE IF NOT EXISTS deposit.financial_products (
  id             BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  institution_id BIGINT NOT NULL REFERENCES deposit.institutions(id) ON DELETE CASCADE,
  name           TEXT NOT NULL,
  product_type   TEXT NOT NULL DEFAULT 'deposit',
  currency       TEXT NOT NULL REFERENCES currency.currencies(code) ON DELETE RESTRICT,
  status         TEXT NOT NULL DEFAULT 'active',
  risk_level     TEXT NOT NULL DEFAULT 'stable',
  amount         NUMERIC(20,6) NOT NULL DEFAULT 0,
  amount_updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_fin_products__type CHECK (product_type IN ('deposit','investment','securities','other')),
  CONSTRAINT ck_fin_products__status CHECK (status IN ('active','inactive','closed')),
  CONSTRAINT ck_fin_products__risk CHECK (risk_level IN ('flexible','stable','high_risk'))
);

CREATE INDEX IF NOT EXISTS idx_fin_products__institution_id
ON deposit.financial_products(institution_id);

DROP TRIGGER IF EXISTS trg_fin_products__upd ON deposit.financial_products;
CREATE TRIGGER trg_fin_products__upd
BEFORE UPDATE ON deposit.financial_products
FOR EACH ROW EXECUTE FUNCTION deposit.tg_set_updated_at();

CREATE TABLE IF NOT EXISTS deposit.product_balances (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id  BIGINT NOT NULL REFERENCES deposit.financial_products(id) ON DELETE CASCADE,
  amount      NUMERIC(20,6) NOT NULL,
  as_of       TIMESTAMPTZ NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_product_balances__product_asof UNIQUE (product_id, as_of),
  CONSTRAINT ck_product_balances__amount_nonneg CHECK (amount >= 0)
);

-- Optional monthly partition example (create as needed)
-- CREATE TABLE deposit.product_balances_2025_01 PARTITION OF deposit.product_balances
-- FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE INDEX IF NOT EXISTS idx_product_balances__product_asof_desc
ON deposit.product_balances (product_id, as_of DESC);

DROP TRIGGER IF EXISTS trg_product_balances__upd ON deposit.product_balances;
CREATE TRIGGER trg_product_balances__upd
BEFORE UPDATE ON deposit.product_balances
FOR EACH ROW EXECUTE FUNCTION deposit.tg_set_updated_at();

DROP TRIGGER IF EXISTS trg_product_balances__sync_amount ON deposit.product_balances;
CREATE TRIGGER trg_product_balances__sync_amount
AFTER INSERT OR UPDATE ON deposit.product_balances
FOR EACH ROW EXECUTE FUNCTION deposit.tg_sync_product_amount();

-- Seeds (tie to first available user if any)
WITH u AS (
  SELECT id FROM "user".users ORDER BY id LIMIT 1
),
inst AS (
  INSERT INTO deposit.institutions(user_id, name, type)
  SELECT u.id, 'Example Bank', 'bank' FROM u
  ON CONFLICT (user_id, name) DO NOTHING
  RETURNING id, user_id, name
),
inst_selected AS (
  SELECT id, user_id, name FROM inst
  UNION ALL
  SELECT i.id, i.user_id, i.name
  FROM deposit.institutions i
  JOIN u ON i.user_id = u.id
  WHERE i.name = 'Example Bank'
  LIMIT 1
),
prod AS (
  INSERT INTO deposit.financial_products(institution_id, name, product_type, currency)
  SELECT i.id, 'Example Savings', 'deposit', 'USD'
  FROM inst_selected i
  ON CONFLICT DO NOTHING
  RETURNING id, institution_id
),
prod_selected AS (
  SELECT id, institution_id FROM prod
  UNION ALL
  SELECT p.id, p.institution_id
  FROM deposit.financial_products p
  JOIN inst_selected i ON p.institution_id = i.id
  WHERE p.name = 'Example Savings'
  LIMIT 1
)
INSERT INTO deposit.product_balances(product_id, amount, as_of)
SELECT p.id, 1000.00, now()
FROM prod_selected p
LIMIT 1;
