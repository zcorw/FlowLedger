-- Flow-Ledger Scheduler schema (PostgreSQL 12+)

CREATE SCHEMA IF NOT EXISTS scheduler;

CREATE OR REPLACE FUNCTION scheduler.tg_set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN NEW.updated_at := now(); RETURN NEW; END $$;

CREATE TABLE IF NOT EXISTS scheduler.jobs (
  id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id         BIGINT NOT NULL REFERENCES "user".users(id) ON DELETE RESTRICT,
  name            TEXT   NOT NULL,
  description     TEXT   NULL,
  rule            TEXT   NOT NULL,
  first_run_at    TIMESTAMPTZ NOT NULL,
  advance_minutes INT    NOT NULL DEFAULT 0,
  channel         TEXT   NOT NULL DEFAULT 'telegram',
  status          TEXT   NOT NULL DEFAULT 'active',
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_jobs__status CHECK (status IN ('active','paused','archived')),
  CONSTRAINT ck_jobs__advance CHECK (advance_minutes BETWEEN 0 AND 10080)
);

CREATE INDEX IF NOT EXISTS idx_jobs__user_id ON scheduler.jobs(user_id);

CREATE TRIGGER trg_jobs__upd
BEFORE UPDATE ON scheduler.jobs
FOR EACH ROW EXECUTE FUNCTION scheduler.tg_set_updated_at();

CREATE TABLE IF NOT EXISTS scheduler.job_runs (
  id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  job_id        BIGINT NOT NULL REFERENCES scheduler.jobs(id) ON DELETE CASCADE,
  period_key    TEXT   NOT NULL,
  scheduled_at  TIMESTAMPTZ NOT NULL,
  sent_at       TIMESTAMPTZ NULL,
  status        TEXT   NOT NULL DEFAULT 'pending',
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_job_runs__job_period UNIQUE (job_id, period_key),
  CONSTRAINT ck_job_runs__status CHECK (status IN ('pending','sent','confirmed','skipped','snoozed','cancelled'))
) PARTITION BY RANGE (scheduled_at);

-- Optional partition example
-- CREATE TABLE scheduler.job_runs_2025_01 PARTITION OF scheduler.job_runs
-- FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE INDEX IF NOT EXISTS idx_job_runs__job_scheduled
ON ONLY scheduler.job_runs (job_id, scheduled_at);

CREATE TRIGGER trg_job_runs__upd
BEFORE UPDATE ON scheduler.job_runs
FOR EACH ROW EXECUTE FUNCTION scheduler.tg_set_updated_at();

CREATE TABLE IF NOT EXISTS scheduler.reminders (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  job_run_id BIGINT NOT NULL REFERENCES scheduler.job_runs(id) ON DELETE CASCADE,
  sent_at    TIMESTAMPTZ NOT NULL,
  payload    JSONB NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TRIGGER trg_reminders__upd
BEFORE UPDATE ON scheduler.reminders
FOR EACH ROW EXECUTE FUNCTION scheduler.tg_set_updated_at();

CREATE TABLE IF NOT EXISTS scheduler.confirmations (
  id               BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  job_run_id       BIGINT NOT NULL REFERENCES scheduler.job_runs(id) ON DELETE CASCADE,
  action           TEXT   NOT NULL,
  confirmed_at     TIMESTAMPTZ NOT NULL,
  idempotency_key  TEXT   NOT NULL,
  payload          JSONB  NULL,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_confirmations__action CHECK (action IN ('complete','skip','snooze','cancel')),
  CONSTRAINT uq_confirmations__run_idem UNIQUE (job_run_id, idempotency_key)
);

CREATE INDEX IF NOT EXISTS idx_confirmations__run_confirmed
ON scheduler.confirmations (job_run_id, confirmed_at DESC);

CREATE TRIGGER trg_confirmations__upd
BEFORE UPDATE ON scheduler.confirmations
FOR EACH ROW EXECUTE FUNCTION scheduler.tg_set_updated_at();

-- Seeds
INSERT INTO scheduler.jobs(user_id, name, rule, first_run_at)
VALUES (1, 'YouTube 订阅', 'cron: 0 10 1 * *', now())
ON CONFLICT DO NOTHING;

INSERT INTO scheduler.job_runs(job_id, period_key, scheduled_at)
SELECT j.id, to_char(now(), 'YYYY-MM'), date_trunc('month', now())
FROM scheduler.jobs j
LIMIT 1;

INSERT INTO scheduler.reminders(job_run_id, sent_at)
SELECT r.id, now() FROM scheduler.job_runs r
LIMIT 1;

