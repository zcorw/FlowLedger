# Deposit 模块 SQL 说明
## 1. 模块范围
- 依赖：引用 `"user".users`、`currency.currencies`
- 实体：`institutions`（用户绑定的金融机构）、`financial_products`（机构下的金融产品，如存款/理财/证券账户等）、`product_balances`（产品余额/持仓快照）

## 2. 字段概览
- `deposit.institutions`
  - `id` BIGINT PK，`user_id` BIGINT FK `"user".users(id)`，`name` TEXT，`type` TEXT(`bank|broker|other`)，`created_at/updated_at`
  - 唯一约束：(`user_id`,`name`)
- `deposit.financial_products`
  - `id` BIGINT PK，`institution_id` BIGINT FK `deposit.institutions(id)`，`name` TEXT，`product_type` TEXT(`deposit|investment|securities|other`)，`currency` TEXT FK `currency.currencies(code)`，`status` TEXT(`active|inactive|closed`)，`risk_level` TEXT(`flexible|stable|high_risk`)，`amount` NUMERIC(20,6) NOT NULL（最新金额快照），`created_at/updated_at`
- `deposit.product_balances`
  - `id` BIGINT PK，`product_id` BIGINT FK `deposit.financial_products(id)`，`amount` NUMERIC(20,6) NOT NULL，`as_of` TIMESTAMPTZ NOT NULL，`created_at/updated_at`
  - 唯一约束：(`product_id`,`as_of`)，金额非负

## 3. 主要 DDL
```sql
CREATE SCHEMA IF NOT EXISTS deposit;

CREATE OR REPLACE FUNCTION deposit.tg_set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN NEW.updated_at := now(); RETURN NEW; END $$;

-- 将最新快照同步到 financial_products.amount
CREATE OR REPLACE FUNCTION deposit.tg_sync_product_amount()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  latest_ts TIMESTAMPTZ;
BEGIN
  SELECT max(as_of) INTO latest_ts
  FROM deposit.product_balances
  WHERE product_id = NEW.product_id;

  IF latest_ts IS NOT NULL AND NEW.as_of = latest_ts THEN
    UPDATE deposit.financial_products
    SET amount = NEW.amount, updated_at = now()
    WHERE id = NEW.product_id;
  END IF;
  RETURN NEW;
END $$;

CREATE TABLE IF NOT EXISTS deposit.institutions (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id    BIGINT NOT NULL REFERENCES "user".users(id) ON DELETE CASCADE,
  name       TEXT NOT NULL,
  type       TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_institutions__type CHECK (type IN ('bank','broker','other')),
  CONSTRAINT uq_institutions__user_name UNIQUE (user_id, name)
);
CREATE INDEX IF NOT EXISTS idx_institutions__user_id ON deposit.institutions(user_id);
CREATE TRIGGER trg_institutions__upd
BEFORE UPDATE ON deposit.institutions
FOR EACH ROW EXECUTE FUNCTION deposit.tg_set_updated_at();

CREATE TABLE IF NOT EXISTS deposit.financial_products (
  id             BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  institution_id BIGINT NOT NULL REFERENCES deposit.institutions(id) ON DELETE CASCADE,
  name           TEXT NOT NULL,
  product_type   TEXT NOT NULL DEFAULT 'deposit',
  currency       TEXT NOT NULL REFERENCES currency.currencies(code) ON DELETE RESTRICT,
  status         TEXT NOT NULL DEFAULT 'active',
  risk_level     TEXT NOT NULL DEFAULT 'stable',
  amount         NUMERIC(20,6) NOT NULL DEFAULT 0,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_fin_products__type CHECK (product_type IN ('deposit','investment','securities','other')),
  CONSTRAINT ck_fin_products__status CHECK (status IN ('active','inactive','closed')),
  CONSTRAINT ck_fin_products__risk CHECK (risk_level IN ('flexible','stable','high_risk'))
);
CREATE INDEX IF NOT EXISTS idx_fin_products__institution_id
  ON deposit.financial_products(institution_id);
CREATE TRIGGER trg_fin_products__upd
BEFORE UPDATE ON deposit.financial_products
FOR EACH ROW EXECUTE FUNCTION deposit.tg_set_updated_at();

CREATE TABLE IF NOT EXISTS deposit.product_balances (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id  BIGINT NOT NULL REFERENCES deposit.financial_products(id) ON DELETE CASCADE,
  amount      NUMERIC(20,6) NOT NULL,
  as_of       TIMESTAMPTZ NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_product_balances__product_asof UNIQUE (product_id, as_of),
  CONSTRAINT ck_product_balances__amount_nonneg CHECK (amount >= 0)
);
-- 可按月分区：PARTITION OF deposit.product_balances FOR VALUES FROM ('2025-01-01') TO ('2025-02-01')
CREATE INDEX IF NOT EXISTS idx_product_balances__product_asof_desc
  ON deposit.product_balances (product_id, as_of DESC);
CREATE TRIGGER trg_product_balances__upd
BEFORE UPDATE ON deposit.product_balances
FOR EACH ROW EXECUTE FUNCTION deposit.tg_set_updated_at();
CREATE TRIGGER trg_product_balances__sync_amount
AFTER INSERT OR UPDATE ON deposit.product_balances
FOR EACH ROW EXECUTE FUNCTION deposit.tg_sync_product_amount();

-- 示例种子数据
INSERT INTO deposit.institutions(user_id, name, type)
VALUES (1, 'Example Bank', 'bank')
ON CONFLICT (user_id, name) DO NOTHING;

INSERT INTO deposit.financial_products(institution_id, name, product_type, currency)
SELECT i.id, 'Example Savings', 'deposit', 'USD'
FROM deposit.institutions i
WHERE i.user_id = 1 AND i.name = 'Example Bank'
ON CONFLICT DO NOTHING;

INSERT INTO deposit.product_balances(product_id, amount, as_of)
SELECT p.id, 1000.00, now()
FROM deposit.financial_products p
JOIN deposit.institutions i ON i.id = p.institution_id
WHERE i.user_id = 1 AND i.name = 'Example Bank'
LIMIT 1;
```

## 4. 约束与幂等
- 机构名在同一用户下唯一；删除用户会级联删除其机构及下属产品/余额。
- `product_balances` 通过 (`product_id`,`as_of`) 保证快照幂等；金额非负。
- `status`/`product_type` 受 CHECK 约束，保障数据质量。

## 5. 示例查询
```sql
-- 查询某用户各产品的最新余额
SELECT p.id AS product_id, p.name, p.product_type, b.amount, b.as_of
FROM deposit.financial_products p
JOIN deposit.institutions i ON i.id = p.institution_id
JOIN LATERAL (
  SELECT amount, as_of
  FROM deposit.product_balances pb
  WHERE pb.product_id = p.id
  ORDER BY as_of DESC
  LIMIT 1
) b ON true
WHERE i.user_id = $1;
```
